#pragma config(Sensor, S2,     leftTouch,      sensorEV3_Touch)
#pragma config(Sensor, S3,     rightTouch,     sensorEV3_Touch)
#pragma config(Motor,  motorA,           ,             tmotorEV3_Large, openLoop)
#pragma config(Motor,  motorB,          leftMotor,     tmotorEV3_Large, PIDControl, driveLeft, encoder)
#pragma config(Motor,  motorC,          rightMotor,    tmotorEV3_Large, PIDControl, driveRight, encoder)
#pragma config(Motor,  motorD,           ,             tmotorEV3_Large, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/**************************************************************
* Title: Challenge 1
* Version: 4/15/2015
* Authors: Cody Tedrick & Brandon Soto
**************************************************************/

/////////////////////////////////////////// constants /////////////////////////////////////////////////////////////////////////////////////////////////////////////
#define THE_DELAY 100						// time to see if another bumper touches (milliseconds)
#define VOLUME 30						// default volume for robot sound
#define MAXPOWER 45						// the robot's max power
#define MINPOWER 15 						// the robot's min power
#define BACKUP_MINTIME 500					// the min time the robot can back up (milliseconds)
#define BACKUP_MAXTIME 1500 					// the max time the robot can back up (milliseconds)
#define FORWARD_MINTIME 500					// the min time the robot can go forward (milliseconds)
#define FORWARD_MAXTIME 2700 					// the max time the robot can go forward (milliseconds)
#define PAUSE_TIME 2						// number of seconds that the robot should pause after both sensors are touched
#define BIAS 4							// the bias for the robot to move in a certain direction. The higher the number, the more influential the bias will be.
#define FORWARD_TIME_RANGE (FORWARD_MAXTIME - FORWARD_MINTIME) 	// time range the robot goes forward
#define BACKUP_TIME_RANGE (BACKUP_MAXTIME - BACKUP_MINTIME) 	// time range the robot goes backward
#define POWER_RANGE (MAXPOWER - MINPOWER) 			// the robot's power range

///////////////////////////////////////////////globals ////////////////////////////////////////////////////////////////////////////////////////////////////////////////
bool respondingToTouch = false; // lock that ensures multiple threads don't issue robot commands at same time (NOTE: only modified in touchThread)

//////////////////////////////////////Function prototypes  ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
unsigned int getRandomFromRange(unsigned int range, unsigned int min);
unsigned int getRandomPower();
unsigned int getRandomBackupTime();
unsigned int getRandomForwardTime();
unsigned int getMaxBias();
unsigned int getMinBias();
void performRandomTurn(unsigned int turnTime, unsigned int aPower);

task touchThread();
task wanderThread();

//////////////////////////////////////Function definitions ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/* main thread */
task main() {
	startTask(wanderThread);
	startTask(touchThread);

	while (true){} // allow other threads to execute}
}

/* returns a random number within a given range with min as start of range */
unsigned int getRandomFromRange(unsigned int range, unsigned int min) {
	return random(range) + min;
}

/* returns a random power number within the robot's power range */
unsigned int getRandomPower() {
	return getRandomFromRange(powRange, minPower);
}

unsigned int getRandomBackupTime() {
	return getRandomFromRange(backupTimeRange, backupMinTime);
}

/* returns a random number for the robot to move in its current direction. */
unsigned int getRandomFowardTime() {
	return getRandomFromRange(forwardTimeRange, forwardMinTime);
}

/* returns a larger biassed number within the robot's power range */
unsigned int getMaxBias() {
	unsigned int turnPower = minPower, i;

	for (i = 0; i < bias; i++) {
		unsigned int randPower = getRandomPower();
		if (randPower > turnPower) {
			turnPower = randPower;
		}
	}

	return turnPower;
}

/* returns a smaller biassed number within the robot's power range */
unsigned int getMinBias() {
	unsigned int turnPower = maxPower, i;

	for (i = 0; i < (int) (bias / 2); i++) {
		unsigned int randPower = getRandomPower();
		if (randPower < turnPower) {
			turnPower = randPower;
		}
	}

	return turnPower;
}

/* Performs a random turn from the given time and power (Note: turnTime should be in milliseconds) */
void performRandomTurn(unsigned int turnTime, unsigned int aPower) {
	if (random(1)) {
		turnLeft(turnTime, milliseconds, aPower);
	} else {
		turnRight(turnTime, milliseconds, aPower);
	}
}

/* thread that handles touch and collision behavior */
task touchThread() {
	setSoundVolume(volume);
	unsigned int turnTime;
	unsigned int avgPower = (unsigned int) (maxPower + minPower) / 2;

	while (true) {
		while (!SensorValue[leftTouch] && !SensorValue[rightTouch]){} // wait until a sensor is touched
		wait(aDelay, milliseconds); // wait a bit to see if other sensor is touched

		respondingToTouch = true; // signal that the robot is about to respond to touch
	 	turnTime = getRandomBackupTime();

		/* respond to collision */
		if (SensorValue[leftTouch] && SensorValue[rightTouch]) { // both sensors touched
				setLEDColor(ledOrange);
				playSound(soundUpwardTones);

				backward(getRandomBackupTime(), milliseconds, avgPower);
				wait(pauseTime, seconds);

				performRandomTurn(turnTime, avgPower);

				setLEDColor(ledGreen);

		}	else if (SensorValue[leftTouch]) { // left touched; turn right
			backward(turnTime, milliseconds, avgPower);
			turnRight(turnTime, milliseconds, avgPower);

		} else { 																		// right touched; turn left
			backward(turnTime, milliseconds, avgPower);
			turnLeft(turnTime, milliseconds, avgPower);
		}

		respondingToTouch = false;
	}
}


/* thread that handles the robot wandering around in a drunken sailor fashion */
task wanderThread() {
	srand(nSysTime);

	/* Represents the robot's current direction relative to its starting direction
	 * (0 = start; positive = right of start; negative = left of start)
	 */
	long posRelativeToStart = 0;
	unsigned int leftPower, rightPower;
	float sleepTime, timerValue;

	while (true) {
		displayCenteredTextLine(1, "Pos: %ld", posRelativeToStart); // display position relative to start position

		if (posRelativeToStart > 0) { 			// robot is currently RIGHT of its starting direction; try turn left
				displayCenteredTextLine(3, "Status: Right of Start");
				leftPower = getMinBias();
				rightPower = getMaxBias();

		} else { 					// robot is currently LEFT of or is facing its starting direction; try turn right
				displayCenteredTextLine(3, "Status: Left of Start");
				leftPower = getMaxBias();
				rightPower = getMinBias();
		}

		sleepTime = getRandomFowardTime();
		posRelativeToStart += ( (leftPower - rightPower) * sleepTime ); // robot's relative pos = old pos + new pos

		displayCenteredTextLine(4, "LP: %u, RP: %u", leftPower, rightPower); 	// display both motor powers
		displayCenteredTextLine(5, "Time: %f", sleepTime); 	// display the current sleep time

		setMotorSpeed(leftMotor, leftPower);
		setMotorSpeed(rightMotor, rightPower);

		resetTimer(T1);

		timerValue =  getTimer(T1, milliseconds); // used for clarity

		while (!respondingToTouch && timerValue < sleepTime) { // wait for touch thread to take over or let the timer finish
			timerValue = getTimer(T1, milliseconds);
		}

		if (respondingToTouch) { // ensures posRelativeToStart is only reset once per iteration
			posRelativeToStart = 0;
			while (respondingToTouch){}
		}

	}
}

