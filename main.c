#pragma config(Sensor, S1,     leftTouch,      sensorEV3_Touch)
#pragma config(Sensor, S2,     rightTouch,     sensorEV3_Touch)
#pragma config(Motor,  motorA,           ,             tmotorEV3_Large, openLoop)
#pragma config(Motor,  motorB,          leftMotor,     tmotorEV3_Large, PIDControl, driveLeft, encoder)
#pragma config(Motor,  motorC,          rightMotor,    tmotorEV3_Large, PIDControl, driveRight, encoder)
#pragma config(Motor,  motorD,           ,             tmotorEV3_Large, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*
* Title: Challenge 1
* Authors: Cody Tedrick & Brandon Soto
*/

///////////////////// TO DO ///////////////////////////////////
// 1) fix both touched case 
// 		* almost finished; must decide how to randomly turn
// 2) make backward length somewhat random 
// 		* fixed, but double check
// 3) make wandering algorithm more biased
// 4) GET RID OF MAGIC NUMBERS - make them constants
//////////////////////////////////////////////////////////////

// globals 
const int speed = 40; 				// robot's default speed
const int robotRightAngle = 180; 		// number for the robot to turn 90 degrees
const int delay = 10;				// time to see if another bumper touches (milliseconds)
const int volume = 50;				// default volume for robot sound
const int maxPower = 35;			// the robot's max power 
const int minPower = 25; 			// the robot's min power
const int backupMinTime = 500;			// the min time the robot should back up (milliseconds)
const int backupMaxTime = 1000; 		// the max time the robot should back up (milliseconds)
const int maxTravelTime = 2500; 		// the max time the robot should move in 1 direction (milliseconds)
const int pauseTime = 2;			// number of seconds that the robot should pause when both sensors are touched
bool respondingToTouch = false; 		// lock that ensures that multiple threads don't issue robot commands at same time (NOTE: only modified in touchThread)

/* thread that handles touch and collision behavior */
task touchThread() {
	setSoundVolume(volume);
	const int backupTimeRange = backupMaxTime - backupMinTime; // the time range that the robot can back up 
	
	while (true) {
		while (!SensorValue[leftTouch] && !SensorValue[rightTouch]); // wait until a sensor is touched
		wait(delay, milliseconds); // wait 10 milliseconds to see if other sensor is touched

		respondingToTouch = true;

		/* respond to collision */
		if (SensorValue[leftTouch] && SensorValue[rightTouch]) { // both touched; turn around
			playSound("soundUpwardTones");
			backward(random(backupTimeRange) + backupMinTime, milliseconds, speed); 
			wait(pauseTime, seconds);
			
			// randomly turn here//////
			// 			TO DO 
			///////////////////////////
		} else if (SensorValue[leftTouch]) { 					// left touched; turn right
			backward(random(backupTimeRange) + backupMinTime, milliseconds, speed); 
			turnRight((int) random(90) + 45, degrees, speed);	// change

		} else { 												// right touched; turn left
			backward(random(backupTimeRange) + backupMinTime, milliseconds, speed);
			turnLeft((int) random(90) + 45, degrees, speed);	// change
		}

		respondingToTouch = false;
	}
}

/* thread that handles the robot wandering around in a drunken sailor fashion */
task wanderThread() {
	srand(nSysTime);
	const int powerRange = maxPower - minPower;	// the robot's power range
	
	while (true) {
		/////////////////////////// try to make biased ///////////////////////////////////////////////

		int leftPower = random(powerRange) + minPower; 			
		int rightPower = random(powerRange) + minPower; 			
		float sleepTime = random(maxTravelTime); 

		setMotorSpeed(leftMotor, leftPower);
		setMotorSpeed(rightMotor, rightPower);

		/////////////////////////////////////////////////////////////////////////////////////////

		resetTimer(T1);
		float valueOfTimer =  getTimer(T1, milliseconds); // used for clarity

		while (!respondingToTouch && valueOfTimer < sleepTime) { // wait for timer to finish or for touch thread to take over
			valueOfTimer = getTimer(T1, milliseconds);
		}

		while(respondingToTouch); // wait for touchThread to finish
	}
}

task main() {
	startTask(wanderThread);
	startTask(touchThread);

	while (true); // allow other threads to execute
}
