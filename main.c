#pragma config(Sensor, S1,     leftTouch,      sensorEV3_Touch)
#pragma config(Sensor, S2,     rightTouch,     sensorEV3_Touch)
#pragma config(Motor,  motorA,           ,             tmotorEV3_Large, openLoop)
#pragma config(Motor,  motorB,          leftMotor,     tmotorEV3_Large, PIDControl, reversed, driveLeft, encoder)
#pragma config(Motor,  motorC,          rightMotor,    tmotorEV3_Large, PIDControl, reversed, driveRight, encoder)
#pragma config(Motor,  motorD,           ,             tmotorEV3_Large, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/**************************************************************
* Title: Challenge 1
* Authors: Cody Tedrick & Brandon Soto
**************************************************************/

///////////////////// TO DO ///////////////////////////////////
// 1) fix both touched case
// 		* almost finished
// 2) make wandering algorithm more biased
// 		* I've attempted a new algorithm. Check over it.
//////////////////////////////////////////////////////////////

// globals
const unsigned int speed = 50; 								// robot's default speed
const unsigned int thedelay = 10;							// time to see if another bumper touches (milliseconds)
const unsigned int volume = 50;								// default volume for robot sound
const unsigned int maxPower = 50;							// the robot's max power
const unsigned int minPower = 20; 						// the robot's min power
const unsigned int backupMinTime = 500;				// the min time the robot should back up (milliseconds)
const unsigned int backupMaxTime = 2000; 			// the max time the robot should back up (milliseconds)
const unsigned int maxTravelTime = 3000; 			// the max time the robot should move in 1 direction (milliseconds)
const unsigned int pauseTime = 2;							// number of seconds that the robot should pause when both sensors are touched
const unsigned int bias = 3;									// the bias for the robot to move in a certain direction. The higher the number, the more influential the bias will be. (should be between 1 - 5)
bool respondingToTouch = false; 							// lock that ensures that multiple threads don't issue robot commands at same time (NOTE: only modified in touchThread)


// returns a random power number within the robot's power range
unsigned int getRandomPower() {
	const int powerRange = maxPower - minPower;	// the robot's power range
	return random(powerRange) + minPower;
}

// returns a larger biassed number within the robot's power range
unsigned int getMaxBias() {
	unsigned int turnPower = minPower;
	int i;

	// finds the max random power
	for (i = 0; i < bias; i++) {
		unsigned int randPower = getRandomPower();
		if (randPower > turnPower) {
			turnPower = randPower;
		}
	}

	return turnPower;
}

// returns a smaller biassed number within the robot's power range
unsigned int getMinBias() {
	unsigned int turnPower = maxPower;
	int i;

	// finds the max random power
	for (i = 0; i < bias; i++) {
		unsigned int randPower = getRandomPower();
		if (randPower < turnPower) {
			turnPower = randPower;
		}
	}

	return turnPower;
}

/* thread that handles touch and collision behavior */
task touchThread() {
	setSoundVolume(volume);
	const int backupTimeRange = backupMaxTime - backupMinTime; // the time range that the robot can back up
	while (true) {
		while (!SensorValue[leftTouch] && !SensorValue[rightTouch]); // wait until a sensor is touched
		wait(thedelay, milliseconds); // wait 10 milliseconds to see if other sensor is touched

		respondingToTouch = true;
		unsigned int turnTime = random(maxTravelTime - 500) + 500; // EDIT LATER

		/* respond to collision */
		if (SensorValue[leftTouch] && SensorValue[rightTouch]) { // both sensors touched
			setLEDColor(ledOrange);
			playSound(soundUpwardTones);
			backward(random(backupTimeRange) + backupMinTime, milliseconds, speed);
			wait(pauseTime, seconds);



			// randomly choose to go left or right
			if (random(1)) {
				turnLeft(turnTime, milliseconds, speed);
			} else {
				turnRight(turnTime, milliseconds, speed);
			}
			setLEDColor(ledGreen);

		} else if (SensorValue[leftTouch]) { 					// left touched; turn right
			backward(random(backupTimeRange) + backupMinTime, milliseconds, speed);
			turnRight(turnTime, milliseconds, speed);

		} else { 												// right touched; turn left
			backward(random(backupTimeRange) + backupMinTime, milliseconds, speed);
			turnLeft(turnTime, milliseconds, speed);
		}

		respondingToTouch = false;
	}
}


/* thread that handles the robot wandering around in a drunken sailor fashion */
task wanderThread() {
	srand(nSysTime);
	long posRelativeToStart = 0; 		// represents the robot's current direction relative to its starting direction (0 = start; positive = right of start; negative = left of start)

	while (true) {
		unsigned int leftPower, rightPower;
		const float sleepTime = random(maxTravelTime);

		if (posRelativeToStart > 0) { // robot is currently left of its starting direction; try to turn right
				displayCenteredTextLine(2, "Going left, try turn right");
				leftPower = getMinBias();
				rightPower = getMaxBias();

		} else { // robot is currently right of or is facing its starting direction; try to turn left
				leftPower = getMaxBias();
				rightPower = getMinBias();
			displayCenteredTextLine(2, "Going right, try turn left");

		}


		const long currDirection = ( (leftPower - rightPower) * sleepTime ); // robot's current direction; used for clarity
		posRelativeToStart += currDirection;


		displayCenteredTextLine(4, "LP: %u, RP: %u", leftPower, rightPower);
		displayCenteredTextLine(5, "Time: %f", sleepTime);
		displayCenteredTextLine(1, "Pos: %ld", posRelativeToStart);

		setMotorSpeed(leftMotor, leftPower);
		setMotorSpeed(rightMotor, rightPower);

		resetTimer(T1);
		float valueOfTimer =  getTimer(T1, milliseconds); // used for clarity

		while (!respondingToTouch && valueOfTimer < sleepTime) { // wait for touch thread to take over or let the timer finish
			valueOfTimer = getTimer(T1, milliseconds);
		}

		while(respondingToTouch) { // wait for touchThread to finish
			posRelativeToStart = 0; // reset starting direction because the robot has bumped into something
			// (TEMPORARY: this is may be executed too many times right now, but I want to prevent turnTotal from being a global variable. However, it might have to be.)
		}
	}
}

task main() {
	startTask(wanderThread);
	startTask(touchThread);

	while (true); // allow other threads to execute
}
