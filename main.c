#pragma config(Sensor, S1,     leftTouch,      sensorEV3_Touch)
#pragma config(Sensor, S2,     rightTouch,     sensorEV3_Touch)
#pragma config(Motor,  motorA,           ,             tmotorEV3_Large, openLoop)
#pragma config(Motor,  motorB,          leftMotor,     tmotorEV3_Large, PIDControl, driveLeft, encoder)
#pragma config(Motor,  motorC,          rightMotor,    tmotorEV3_Large, PIDControl, driveRight, encoder)
#pragma config(Motor,  motorD,           ,             tmotorEV3_Large, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/**************************************************************
* Title: Challenge 1
* Authors: Cody Tedrick & Brandon Soto
**************************************************************/

///////////////////// TO DO ///////////////////////////////////
// 1) fix both touched case 
// 		* almost finished; must decide how to randomly turn
// 2) make wandering algorithm more biased
// 		* I've attempted a new algorithm. Check over it. 
//////////////////////////////////////////////////////////////

// globals 
const unsigned int speed = 40; 					// robot's default speed
const unsigned int robotRightAngle = 180; 		// number for the robot to turn 90 degrees
const unsigned int delay = 10;					// time to see if another bumper touches (milliseconds)
const unsigned int volume = 50;					// default volume for robot sound
const unsigned int maxPower = 35;				// the robot's max power 
const unsigned int minPower = 25; 				// the robot's min power
const unsigned int backupMinTime = 500;			// the min time the robot should back up (milliseconds)
const unsigned int backupMaxTime = 1000; 		// the max time the robot should back up (milliseconds)
const unsigned int maxTravelTime = 2500; 		// the max time the robot should move in 1 direction (milliseconds)
const unsigned int pauseTime = 2;				// number of seconds that the robot should pause when both sensors are touched
const unsigned int bias = 6;					// the bias for the robot to move in a certain direction. The higher the number, the more influential the bias will be. (should be between 1 - 10)
bool respondingToTouch = false; 				// lock that ensures that multiple threads don't issue robot commands at same time (NOTE: only modified in touchThread)

/* thread that handles touch and collision behavior */
task touchThread() {
	setSoundVolume(volume);
	const int backupTimeRange = backupMaxTime - backupMinTime; // the time range that the robot can back up 
	const int turnAngle = robotRightAngle / 2; // half of the number of degrees it takes for the robot to turn 90 degrees
	while (true) {
		while (!SensorValue[leftTouch] && !SensorValue[rightTouch]); // wait until a sensor is touched
		wait(delay, milliseconds); // wait 10 milliseconds to see if other sensor is touched

		respondingToTouch = true;

		/* respond to collision */
		if (SensorValue[leftTouch] && SensorValue[rightTouch]) { // both sensors touched 
			playSound("soundUpwardTones");
			backward(random(backupTimeRange) + backupMinTime, milliseconds, speed); 
			wait(pauseTime, seconds);
			
			// randomly turn here/////////////////////////////////
			// 			TO DO 
			// 		unsure if we should do point or swerve turns
			/////////////////////////////////////////////////////
		} else if (SensorValue[leftTouch]) { 					// left touched; turn right
			backward(random(backupTimeRange) + backupMinTime, milliseconds, speed); 
			turnRight((int) random(turnAngle) + (turnAngle), degrees, speed); // should turn between 45 - 90 degrees

		} else { 												// right touched; turn left
			backward(random(backupTimeRange) + backupMinTime, milliseconds, speed);
			turnLeft(int) random(turnAngle) + (turnAngle), degrees, speed);	// should turn between 45 - 90 degrees
		}

		respondingToTouch = false;
	}
}

// returns a random power number within the robot's power range
unsigned int getRandomPower() {
	const int powerRange = maxPower - minPower;	// the robot's power range
	return random(powerRange) + minPower;
}

// returns a biassed power number within the robot's power range
unsigned int getBiassedPower() {
	unsigned int turnPower = 0;
	int i;
	
	// finds the max random power
	for (i = 0; i < bias; i++) {
		unsigned int randPower = getRandomPower();
		if (randPower > turnPower) {
			turnPower = randPower;
		}
	}
	
	return turnPower;
}

/* thread that handles the robot wandering around in a drunken sailor fashion */
task wanderThread() {
	srand(nSysTime);
	long posRelativeToStart = 0; 		// represents the robot's current direction relative to its starting direction (0 = start; positive = left of start; negative = right of start)
	
	while (true) {
		unsigned int leftPower, rightPower;
		const float sleepTime = random(maxTravelTime);
		
		// NOTE: /////////////////////////////////////////////////////////////
		// right turns 	= the LEFT wheel must move faster than the RIGHT wheel
		// left turns 	= the RIGHT wheel must move faster than the LEFT wheel
		//////////////////////////////////////////////////////////////////////
		
		if (posRelativeToStart > 0) { // robot is currently left of its starting direction; try to turn right
			leftPower = getBiassedPower();
			rightPower = getRandomPower();
		} else { // robot is currently right of or is facing its starting direction; try to turn left
			leftPower = getRandomPower();
			rightPower = getBiassedPower();
		}
		
		const long currDirection = ( (leftPower - rightPower) * sleepTime ); // robot's current direction; used for clarity
		posRelativeToStart += currDirection;
		
		setMotorSpeed(leftMotor, leftPower);
		setMotorSpeed(rightMotor, rightPower);

		resetTimer(T1);
		const float valueOfTimer =  getTimer(T1, milliseconds); // used for clarity

		while (!respondingToTouch && valueOfTimer < sleepTime) { // wait for touch thread to take over or let the timer finish
			valueOfTimer = getTimer(T1, milliseconds);
		}

		while(respondingToTouch) { // wait for touchThread to finish
			posRelativeToStart = 0; // reset starting direction because the robot has bumped into something 
			// (TEMPORARY: this is may be executed too many times right now, but I want to prevent turnTotal from being a global variable. However, it might have to be.)
		}
	}
}

task main() {
	startTask(wanderThread);
	startTask(touchThread);

	while (true); // allow other threads to execute
}
